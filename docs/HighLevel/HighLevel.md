<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'hl' Dialect

A high-level verbose program analysis MLIR dialect.
This dialect intends capture highevel constructs of C/C++
for further program analysis.

[TOC]

## Operation definition

### `hl.access` (::vast::hl::AccessSpecifierOp)

VAST C++ access specifier declaration


Syntax:

```
operation ::= `hl.access` attr-dict $spec
```

VAST C++ access specifier declaration
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `spec` | ::vast::hl::AccessSpecifierAttr | Access specifier

### `hl.assign.fadd` (::vast::hl::AddFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fadd` (::vast::hl::AddFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.add` (::vast::hl::AddIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.add` (::vast::hl::AddIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

Traits: Commutative

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.labeladdr` (::vast::hl::AddrLabelExpr)

VAST address of label extension


Syntax:

```
operation ::= `hl.labeladdr` $label attr-dict `:` type($result)
```

VAST address of label extension
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` | 

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to pointer like type

### `hl.addressof` (::vast::hl::AddressOf)

VAST addressof operation


Syntax:

```
operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result)
```

VAST addressof operation
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.alignof.expr` (::vast::hl::AlignOfExprOp)

VAST expr alignof operator


Syntax:

```
operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr
```

VAST expr alignof operator
#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.alignof.type` (::vast::hl::AlignOfTypeOp)

VAST type alignof operator


Syntax:

```
operation ::= `hl.alignof.type` $arg attr-dict `->` type($result)
```

VAST type alignof operator
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `arg` | ::mlir::TypeAttr | any type attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign` (::vast::hl::AssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.and` (::vast::hl::BinAndAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.and` (::vast::hl::BinAndOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.comma` (::vast::hl::BinComma)

VAST binary operation


Syntax:

```
operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```


Traits: AttrSizedOperandSegments

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.land` (::vast::hl::BinLAndOp)

VAST logical binary operation


Syntax:

```
operation ::= `hl.bin.land` $lhs`,` $rhs attr-dict `:` type(results)
```

High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.lor` (::vast::hl::BinLOrOp)

VAST logical binary operation


Syntax:

```
operation ::= `hl.bin.lor` $lhs`,` $rhs attr-dict `:` type(results)
```

High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.or` (::vast::hl::BinOrAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.or` (::vast::hl::BinOrOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.shl` (::vast::hl::BinShlAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to integer like type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.bin.shl` (::vast::hl::BinShlOp)

VAST binary shift operation


Syntax:

```
operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level binary shift operation. This operation takes two operands
and returns one result.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | integer like type
| `rhs` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign.bin.shr` (::vast::hl::BinShrAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.shr` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to integer like type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.bin.shr` (::vast::hl::BinShrOp)

VAST binary shift operation


Syntax:

```
operation ::= `hl.bin.shr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level binary shift operation. This operation takes two operands
and returns one result.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | integer like type
| `rhs` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign.bin.xor` (::vast::hl::BinXorAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.xor` (::vast::hl::BinXorOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.builtin_bitcast` (::vast::hl::BuiltinBitCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.cstyle_cast` (::vast::hl::CStyleCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.call` (::vast::hl::CallOp)

VAST call operation


Syntax:

```
operation ::= `hl.call` $callee `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )
```

VAST call operation
Interfaces: CallOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `argOperands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | any type

### `hl.class` (::vast::hl::ClassDeclOp)

VAST C++ class declaration


Syntax:

```
operation ::= `hl.class` $name attr-dict `:` `bases` $bases $fields
```

VAST C++ class declaration
Traits: NoTerminator

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.cmp` (::vast::hl::CmpOp)

VAST comparison operation


Syntax:

```
operation ::= `hl.cmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `->` type($result)
```

VAST comparison operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `predicate` | ::vast::hl::PredicateAttr | comparison predicate

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | bool or integer like type

### `hl.const` (::vast::hl::ConstantOp)

VAST integral constant


Syntax:

```
operation ::= `hl.const` $value attr-dict
```

VAST integral constant
Traits: ConstantLike

Interfaces: InferTypeOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::TypedAttr | TypedAttr instance

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.base` (::vast::hl::CxxBaseSpecifierOp)

VAST base class specifier


Syntax:

```
operation ::= `hl.base` $type attr-dict $access (`virtual` $is_virtual^)?
```

VAST base class specifier
Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `type` | ::mlir::TypeAttr | any type attribute
| `access` | ::vast::hl::AccessSpecifierAttr | Access specifier
| `is_virtual` | ::mlir::UnitAttr | unit attribute

### `hl.cxxstruct` (::vast::hl::CxxStructDeclOp)

VAST C++ struct declaration


Syntax:

```
operation ::= `hl.cxxstruct` $name attr-dict `:` `bases` $bases $fields
```

VAST C++ struct declaration
Traits: NoTerminator

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.ref` (::vast::hl::DeclRefOp)

VAST variable reference declaration


Syntax:

```
operation ::= `hl.ref` $decl attr-dict `:`type(operands)
```

VAST variable reference declaration
Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `decl` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to any type

### `hl.deref` (::vast::hl::Deref)

VAST deref operation


Syntax:

```
operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result)
```

VAST deref operation
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `addr` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to any type

### `hl.assign.fdiv` (::vast::hl::DivFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fdiv` (::vast::hl::DivFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.sdiv` (::vast::hl::DivSAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.sdiv` (::vast::hl::DivSOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.udiv` (::vast::hl::DivUAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.udiv` (::vast::hl::DivUOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.enum.const` (::vast::hl::EnumConstantOp)

VAST enum constant declaration


Syntax:

```
operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)?
```

Enumeration constant servers to link name to an enum value.
It is required to be scoped in Enum operation. For example:

```
hl.enum.const "F" = 2 : !hl.int
```

A constant can have a constant expression initializer:

```
hl.enum.const "G" = #hl.integer<12> : !hl.int init  {
  %0 = hl.enumref "F" : !hl.int
  %1 = hl.enumref "C" : !hl.int
  %2 = hl.add %0, %1 : !hl.int
  hl.value.yield %2 : !hl.int
}
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `value` | ::mlir::TypedAttr | TypedAttr instance

### `hl.enum` (::vast::hl::EnumDeclOp)

VAST enum declaration


Syntax:

```
operation ::= `hl.enum` $name attr-dict `:` $type $constants
```

Enum declaration serves to declare region for enum constant declarations.
It also defines an underlying type.

Traits: NoTerminator

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute

### `hl.enumref` (::vast::hl::EnumRefOp)

VAST variable reference declaration


Syntax:

```
operation ::= `hl.enumref` $value attr-dict `:` type($result)
```

VAST variable reference declaration
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.expr` (::vast::hl::ExprOp)

VAST expression


Syntax:

```
operation ::= `hl.expr` attr-dict `:` type($result) $subexpr
```

VAST expression
Traits: SingleBlock

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.gnu.extension` (::vast::hl::ExtensionOp)

VAST extension (__extension__) keyword


Syntax:

```
operation ::= `hl.gnu.extension` $value attr-dict `:` type($value) `->` type($result)
```

VAST op corresponding to GNU __extension__ keyword.
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fcmp` (::vast::hl::FCmpOp)

VAST flaoting point comparison operation


Syntax:

```
operation ::= `hl.fcmp` $predicate $lhs `,` $rhs  attr-dict `:` type(operands) `->` type($result)
```

VAST flaoting point comparison operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `predicate` | ::vast::hl::FPredicateAttr | floating point comparison predicate

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | float like type
| `rhs` | float like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | bool or integer like type

### `hl.field` (::vast::hl::FieldDeclOp)

VAST record field declaration


Syntax:

```
operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type
```

VAST record field declaration
Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute
| `bits` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `hl.func` (::vast::hl::FuncOp)

VAST high-level function definintion or declaration


Syntax:

```
operation ::= `hl.func` $linkage $sym_name custom< FunctionSignatureAndBody >($function_type, attr-dict, $body)
```

Inspired by `cir::FuncOp` and `mlir::func::FuncOp`:
> Operations within the function cannot implicitly capture values defined
> outside of the function, i.e. Functions are `IsolatedFromAbove`. All
> external references must use function arguments or attributes that establish
> a symbolic connection (e.g. symbols referenced by name via a string
> attribute like SymbolRefAttr). An external function declaration (used when
> referring to a function declared in some other module) has no body.

The function linkage information is specified by `linkage`, as defined by
`GlobalLinkageKind` attribute.

Traits: AutomaticAllocationScope, IsolatedFromAbove, NoTerminator

Interfaces: CallableOpInterface, FunctionOpInterface, Symbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sym_name` | ::mlir::StringAttr | string attribute
| `function_type` | ::mlir::TypeAttr | type attribute of function type
| `linkage` | ::vast::hl::GlobalLinkageKindAttr | Linkage type/kind
| `sym_visibility` | ::mlir::StringAttr | string attribute
| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes
| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes

### `hl.funcref` (::vast::hl::FuncRefOp)

VAST function reference declaration


Syntax:

```
operation ::= `hl.funcref` $function attr-dict `:` type($result)
```

VAST function reference declaration
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `function` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.globref` (::vast::hl::GlobalRefOp)

VAST global variable reference declaration


Syntax:

```
operation ::= `hl.globref` $global attr-dict `:` type($result)
```

VAST global variable reference declaration
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `global` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.break` (::vast::hl::BreakOp)

VAST break statement


Syntax:

```
operation ::= `hl.break` attr-dict
```

VAST break statement
Traits: NoRegionArguments, NoTerminator, soft_terminator

### `hl.case` (::vast::hl::CaseOp)

VAST case statement


Syntax:

```
operation ::= `hl.case` $lhs $body attr-dict
```

The operation represents a single case of a switch statement.

The generic form of the operation is as follows:

hl.case {
  ... /* lhs/check region */
  hl.value.yield %val : !hl.type
} {
  ... /* body region */
}

It represents a C statement of form `case lhs: body;`.

Traits: NoRegionArguments, NoTerminator

### `hl.cond` (::vast::hl::CondOp)

VAST conditional statement


Syntax:

```
operation ::= `hl.cond` $condRegion `?` $thenRegion `:` $elseRegion attr-dict `:` type(results)
```

The operation takes builders of three regions -- condition, true branch and false branch.
Builders, given the location, build a particular region.

The generic form of the operation is as follows:

hl.cond {
  ... /* condition region */
  hl.cond.yield %cond : !hl.bool
} ? {
  ... /* true region */
} : {
  ... /* false region */
}

Traits: NoRegionArguments, NoTerminator

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.cond.yield` (::vast::hl::CondYieldOp)

condition yield operation


Syntax:

```
operation ::= `hl.cond.yield` attr-dict $result `:` type($result)
```

A condition yield operation is used to terminate the region representing
condition expression of control flow operations `IfOp`, `WhileOp`, `ForOp`
and `DoOp`. It yields a boolean value for the conditional branch.

The custom assembly form of the operation is as follows:

hl.cond.yield result : BoolType

Traits: HasParent<IfOp, WhileOp, ForOp, DoOp, CondOp>, Terminator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.continue` (::vast::hl::ContinueOp)

VAST continue statement


Syntax:

```
operation ::= `hl.continue` attr-dict
```

VAST continue statement
Traits: NoRegionArguments, NoTerminator, soft_terminator

### `hl.default` (::vast::hl::DefaultOp)

VAST default statement


Syntax:

```
operation ::= `hl.default` $body attr-dict
```

VAST default statement
Traits: NoRegionArguments, NoTerminator

### `hl.do` (::vast::hl::DoOp)

VAST do-while statement


Syntax:

```
operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict
```

The operation represents a do-while statement.

The generic form of the operation is as follows:

hl.do {
  ... /* body region */
} cond {
  ... /* cond region */
  hl.cond.yield %cond : !hl.bool
}

Traits: NoRegionArguments, NoTerminator

### `hl.for` (::vast::hl::ForOp)

VAST for statement


Syntax:

```
operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion
```

Operation represents a for-loop statement.

The generic form of the operation is as follows:

hl.for {
  ... /* cond region */
  hl.cond.yield %cond : !hl.bool
} incr {
  ... /* increment/update region */
} do {
  ... /* body region */
}

Traits: NoRegionArguments, NoTerminator

### `hl.goto` (::vast::hl::GotoStmt)




Syntax:

```
operation ::= `hl.goto` $label attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` | 

### `hl.if` (::vast::hl::IfOp)

VAST if statement

The operation takes builders of two mandatory regions -- condition and then
region -- and one builder optional region representing else block of C if statement.
Builders, given the location, build a particular region.

The generic form of the operation is as follows:

hl.if {
  ... /* condition region */
  hl.cond.yield %cond : !hl.bool
} then {
  ... /* then region */
} else {
  ... /* else region */
}

Traits: NoRegionArguments, NoTerminator

### `hl.label.decl` (::vast::hl::LabelDeclOp)




Syntax:

```
operation ::= `hl.label.decl` $name attr-dict `:` type($result)
```


Interfaces: InferTypeOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 

### `hl.label` (::vast::hl::LabelStmt)

VAST control flow operation


Syntax:

```
operation ::= `hl.label` $label $body attr-dict
```

VAST control flow operation
Traits: NoRegionArguments, NoTerminator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` | 

### `hl.skip` (::vast::hl::SkipStmt)

VAST skip statement


Syntax:

```
operation ::= `hl.skip` attr-dict
```

VAST skip statement
### `hl.switch` (::vast::hl::SwitchOp)

VAST switch statement


Syntax:

```
operation ::= `hl.switch` $condRegion `cases` $cases attr-dict
```

The operation represents a switch statement.

The generic form of the operation is as follows:

hl.switch {
  ... /* cond region */
  hl.value.yield %val : !hl.type
} cases {
  ... /* casesregion */
}

Traits: NoRegionArguments, NoTerminator

### `hl.value.yield` (::vast::hl::ValueYieldOp)

value yield operation


Syntax:

```
operation ::= `hl.value.yield` attr-dict $result `:` type($result)
```

A value yield operation is used to terminate the case region of a switch
statement. The yielded value triggers the parent case statement region.

The custom assembly form of the operation is as follows:

hl.value.yield result : type

Traits: Terminator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.var` (::vast::hl::VarDeclOp)

VAST variable declaration


Syntax:

```
operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result)
              (`=` $initializer^)?
              (`allocation_size` $allocation_size^)?
```

VAST variable declaration
Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `storageClass` | ::vast::hl::StorageClassAttr | storage class
| `threadStorageClass` | ::vast::hl::TSClassAttr | thread storage class

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.while` (::vast::hl::WhileOp)

VAST while statement


Syntax:

```
operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict
```

The operation takes builders of two mandatory regions -- condition and body
region. Builders, given the location, build a particular region.

The generic form of the operation is as follows:

hl.while {
  ... /* condition region */
  hl.cond.yield %cond : !hl.bool
} do {
  ... /* body region */
}

Traits: NoRegionArguments, NoTerminator

### `hl.implicit_cast` (::vast::hl::ImplicitCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.indirect_call` (::vast::hl::IndirectCallOp)

VAST call operation


Syntax:

```
operation ::= `hl.indirect_call` $callee `:` type($callee)  `(` $argOperands `)` attr-dict `:` functional-type( $argOperands, $results )
```

VAST call operation
Interfaces: CallOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `callee` | any type
| `argOperands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `results` | any type

### `hl.initlist` (::vast::hl::InitListExpr)

VAST initializer list expression


Syntax:

```
operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results)
```

VAST initializer list expression
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `elements` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | any type

### `hl.lnot` (::vast::hl::LNotOp)

VAST unary logical operation


Syntax:

```
operation ::= `hl.lnot` $arg attr-dict `:` type($arg) `->` type($res)
```

High-level unary logical operation assures that
result has the right type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type -> ret_type

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `res` | bool or integer like type

### `hl.minus` (::vast::hl::MinusOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.minus` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.fmul` (::vast::hl::MulFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fmul` (::vast::hl::MulFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.mul` (::vast::hl::MulIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.mul` (::vast::hl::MulIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

Traits: Commutative

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.not` (::vast::hl::NotOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.not` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.plus` (::vast::hl::PlusOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.plus` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.post.dec` (::vast::hl::PostDecOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.post.inc` (::vast::hl::PostIncOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.pre.dec` (::vast::hl::PreDecOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.pre.inc` (::vast::hl::PreIncOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.predefined.expr` (::vast::hl::PredefinedExpr)

VAT predefined expr ( such as __func__ )


Syntax:

```
operation ::= `hl.predefined.expr` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAT predefined expr ( such as __func__ )
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::IdentKindAttr | ident kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.member` (::vast::hl::RecordMemberOp)

VAST record element access operation


Syntax:

```
operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element)
```

VAST record element access operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `record` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `element` | lvalue to any type

### `hl.assign.frem` (::vast::hl::RemFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.frem` (::vast::hl::RemFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.srem` (::vast::hl::RemSAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.srem` (::vast::hl::RemSOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.urem` (::vast::hl::RemUAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.urem` (::vast::hl::RemUOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.return` (::vast::hl::ReturnOp)




Syntax:

```
operation ::= `hl.return` ($result^ `:` type($result))? attr-dict
```


Traits: soft_terminator

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.scope` (::vast::hl::ScopeOp)

VAST scope declaration


Syntax:

```
operation ::= `hl.scope` $body attr-dict
```

Scope operation servers to represent explicitly high-level code scope.
Other control flow operations represent scopes implicitly.  It is a
single-region operation.

Traits: NoTerminator

### `hl.sizeof.expr` (::vast::hl::SizeOfExprOp)

VAST expr sizeof operator


Syntax:

```
operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr
```

VAST expr sizeof operator
#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.sizeof.type` (::vast::hl::SizeOfTypeOp)

VAST type sizeof operator


Syntax:

```
operation ::= `hl.sizeof.type` $arg attr-dict `->` type($result)
```

VAST type sizeof operator
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `arg` | ::mlir::TypeAttr | any type attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.stmt.expr` (::vast::hl::StmtExprOp)

VAST statement expression


Syntax:

```
operation ::= `hl.stmt.expr` attr-dict `:` type($result) $substmt
```

VAST statement expression
Traits: NoTerminator, SingleBlock

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.struct` (::vast::hl::StructDeclOp)

VAST struct declaration


Syntax:

```
operation ::= `hl.struct` $name attr-dict `:` $fields
```

VAST struct declaration
Traits: NoTerminator

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.assign.fsub` (::vast::hl::SubFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fsub` (::vast::hl::SubFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.sub` (::vast::hl::SubIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : functional-type(operands, results)

It represents C compound assignment statement:

dst =<op> src;

Interfaces: InferTypeOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.sub` (::vast::hl::SubIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.subscript` (::vast::hl::SubscriptOp)

VAST array subscript operator


Syntax:

```
operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict
              `:` type($array) `->` type($result)
```

VAST array subscript operator
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `array` | lvalue to subscriptable type
| `index` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to any type

### `hl.this` (::vast::hl::ThisOp)

VAST this operator


Syntax:

```
operation ::= `hl.this` attr-dict `:` type($result)
```

VAST this operator
#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.translation_unit` (::vast::hl::TranslationUnitOp)

VAST translation unit


Syntax:

```
operation ::= `hl.translation_unit` $body attr-dict
```

VAST tranaslation unit
Traits: IsolatedFromAbove, NoTerminator, SymbolTable

### `hl.type` (::vast::hl::TypeDeclOp)

VAST type declaration


Syntax:

```
operation ::= `hl.type` $name attr-dict
```

VAST type declaration
Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.typedef` (::vast::hl::TypeDefOp)

VAST typedef operation


Syntax:

```
operation ::= `hl.typedef` $name attr-dict `:` $type
```

Typedef operation servers to declare named types.
It creates a new type symbol in the current scope to
be referenced as NamedType later.

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute

### `hl.union` (::vast::hl::UnionDeclOp)

VAST record declaration


Syntax:

```
operation ::= `hl.union` $name attr-dict `:` $fields
```

VAST record declaration
Traits: NoTerminator

Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.unreachable` (::vast::hl::UnreachableOp)

VAST unreachable operation


Syntax:

```
operation ::= `hl.unreachable` attr-dict
```

VAST unreachable operation
Traits: Terminator

## Attribute definition

### AnnotationAttr



Syntax:

```
#hl.annotation<
  ::mlir::StringAttr   # name
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::mlir::StringAttr` |  |

### BooleanAttr

An Attribute containing a boolean value

Syntax:

```
#hl.bool<
  ::mlir::Type,   # type
  bool   # value
>
```

An boolean attribute is a literal attribute that represents a boolean value.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| value | `bool` |  |

### CVQualifiersAttr



Syntax:

```
#hl.quals<
  bool,   # is_const
  bool   # is_volatile
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| is_const | `bool` | const qualifier |
| is_volatile | `bool` | volatile qualifier |

### CVRQualifiersAttr



Syntax:

```
#hl.quals<
  bool,   # is_const
  bool,   # is_volatile
  bool   # is_restrict
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| is_const | `bool` | const qualifier |
| is_volatile | `bool` | volatile qualifier |
| is_restrict | `bool` | restrict qualifier |

### FloatAttr

An Attribute containing a floating point value

Syntax:

```
#hl.float<
  ::mlir::Type,   # type
  ::llvm::APFloat   # value
>
```

A float attribute is a literal attribute that represents a floating point
value of the specified floating point type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| value | `::llvm::APFloat` |  |

### IntegerAttr

An Attribute containing a integer value

Syntax:

```
#hl.integer<
  ::mlir::Type,   # type
  ::llvm::APSInt   # value
>
```

An integer attribute is a literal attribute that represents an integral
value of the specified integer type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| value | `::llvm::APSInt` |  |

### StringAttr

An Attribute containing a string

Syntax:

```
#hl.str<
  ::llvm::StringRef,   # value
  ::mlir::Type   # type
>
```

Note: Temporarily copied from builtin dialect, because llvm-15 does not have
`TypedAttrInterface` yet.

Syntax:

```
string-attribute ::= string-literal (`:` type)?
```

A string attribute is an attribute that represents a string literal value.

Examples:

```mlir
"An important string"
"string with a type" : !dialect.string
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::llvm::StringRef` |  |
| type | `::mlir::Type` |  |

### StringLiteralAttr

An Attribute containing an escaped string

Syntax:

```
string-attribute ::= string-literal (`:` type)?
```

A string literal attribute is an attribute that represents an escaped string literal value.

Examples:

```mlir
"An important string"
"string with a type" : !dialect.string
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::llvm::StringRef` |  |
| type | `::mlir::Type` |  |

### UCVQualifiersAttr



Syntax:

```
#hl.quals<
  bool,   # is_unsigned
  bool,   # is_const
  bool   # is_volatile
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| is_unsigned | `bool` | unsigned qualifier |
| is_const | `bool` | const qualifier |
| is_volatile | `bool` | volatile qualifier |

## Type definition

### AdjustedType



Syntax:

```
!hl.adjusted<
  Type,   # original
  Type   # adjusted
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| original | `Type` |  |
| adjusted | `Type` |  |

### ArrayType



Syntax:

```
!hl.array<
  SizeParam,   # size
  Type,   # elementType
  CVRQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| size | `SizeParam` | size parameter for arrays |
| elementType | `Type` |  |
| quals | `CVRQualifiersAttr` |  |

### AttributedType



Syntax:

```
!hl.attributed<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### BFloat16Type



Syntax:

```
!hl.bfloat16<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### BoolType



Syntax:

```
!hl.bool<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### CharType



Syntax:

```
!hl.char<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### DecayedType



Syntax:

```
!hl.decayed<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### DoubleType



Syntax:

```
!hl.double<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### ElaboratedType



Syntax:

```
!hl.elaborated<
  Type,   # elementType
  CVRQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |
| quals | `CVRQualifiersAttr` |  |

### EnumType



Syntax:

```
!hl.enum<
  ::llvm::StringRef,   # name
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::llvm::StringRef` |  |
| quals | `CVQualifiersAttr` |  |

### Float128Type



Syntax:

```
!hl.float128<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### FloatType



Syntax:

```
!hl.float<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### HalfType



Syntax:

```
!hl.half<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### Int128Type



Syntax:

```
!hl.int128<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### IntType



Syntax:

```
!hl.int<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### LValueType



Syntax:

```
!hl.lvalue<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### LabelType



Syntax: `!hl.label`


### LongDoubleType



Syntax:

```
!hl.longdouble<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

### LongLongType



Syntax:

```
!hl.longlong<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### LongType



Syntax:

```
!hl.long<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### ParenType



Syntax:

```
!hl.paren<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### PointerType



Syntax:

```
!hl.ptr<
  Type,   # elementType
  CVRQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |
| quals | `CVRQualifiersAttr` |  |

### RValueType



Syntax:

```
!hl.rvalue<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### RecordType



Syntax:

```
!hl.record<
  ::llvm::StringRef,   # name
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::llvm::StringRef` |  |
| quals | `CVQualifiersAttr` |  |

### ReferenceType



Syntax:

```
!hl.reference<
  Type   # elementType
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### ShortType



Syntax:

```
!hl.short<
  UCVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `UCVQualifiersAttr` |  |

### TypedefType



Syntax:

```
!hl.typedef<
  ::llvm::StringRef,   # name
  CVRQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::llvm::StringRef` |  |
| quals | `CVRQualifiersAttr` |  |

### VoidType



Syntax:

```
!hl.void<
  CVQualifiersAttr   # quals
>
```


#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| quals | `CVQualifiersAttr` |  |

