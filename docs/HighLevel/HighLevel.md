<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'hl' Dialect

A high-level verbose program analysis MLIR dialect.
This dialect intends capture highevel constructs of C/C++
for further program analysis.

[TOC]

## Attribute definition

### AnnotationAttr




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::mlir::StringAttr` |  |

### TypeNameAttr




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::mlir::StringAttr` |  |

## Type constraint definition

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

###

## Operation definition

### `hl.constant.int` (::vast::hl::ConstantIntOp)

VAST integral constant

VAST integral constant
Traits: ConstantLike

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::IntegerAttr | arbitrary integer attribute with sign

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | bool or integer like type

### `hl.assign.fadd` (::vast::hl::AddFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fadd` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fadd` (::vast::hl::AddFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fadd` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.add` (::vast::hl::AddIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.add` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.add` (::vast::hl::AddIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.add` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: Commutative, SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.labeladdr` (::vast::hl::AddrLabelExpr)

VAST address of label extension


Syntax:

```
operation ::= `hl.labeladdr` $label attr-dict `:` type($result)
```

VAST address of label extension
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` |

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to

### `hl.addressof` (::vast::hl::AddressOf)

VAST addressof operation


Syntax:

```
operation ::= `hl.addressof` $value attr-dict `:` type($value) `->` type($result)
```

VAST addressof operation
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.alignof.expr` (::vast::hl::AlignOfExprOp)

VAST expr alignof operator


Syntax:

```
operation ::= `hl.alignof.expr` attr-dict `->` type($result) $expr
```

VAST expr alignof operator
Traits: RecursiveSideEffects

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.alignof.type` (::vast::hl::AlignOfTypeOp)

VAST type alignof operator


Syntax:

```
operation ::= `hl.alignof.type` $type attr-dict `->` type($result)
```

VAST type alignof operator
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `type` | ::mlir::TypeAttr | any type attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign` (::vast::hl::AssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.and` (::vast::hl::BinAndAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.and` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.and` (::vast::hl::BinAndOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.and` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.comma` (::vast::hl::BinComma)

VAST binary operation


Syntax:

```
operation ::= `hl.bin.comma` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```


Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.land` (::vast::hl::BinLAndOp)

VAST logical binary operation


Syntax:

```
operation ::= `hl.bin.land` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.lor` (::vast::hl::BinLOrOp)

VAST logical binary operation


Syntax:

```
operation ::= `hl.bin.lor` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level logical binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.or` (::vast::hl::BinOrAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.or` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.or` (::vast::hl::BinOrOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.or` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.bin.shl` (::vast::hl::BinShlAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.shl` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to integer like type
| `dst` | lvalue to integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.bin.shl` (::vast::hl::BinShlOp)

VAST binary shift operation


Syntax:

```
operation ::= `hl.bin.shl` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level binary shift operation. This operation takes two operands
and returns one result.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | integer like type
| `rhs` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign.bin.shr` (::vast::hl::BinShrAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.shr` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to integer like type
| `dst` | lvalue to integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.bin.shr` (::vast::hl::BinShrOp)

VAST binary shift operation


Syntax:

```
operation ::= `hl.bin.shr` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```

High-level binary shift operation. This operation takes two operands
and returns one result.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : functional-type(operands, results)

Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | integer like type
| `rhs` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.assign.bin.xor` (::vast::hl::BinXorAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.bin.xor` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.bin.xor` (::vast::hl::BinXorOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.bin.xor` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.break` (::vast::hl::BreakOp)

VAST break statement


Syntax:

```
operation ::= `hl.break` attr-dict
```

VAST break statement
Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.builtin_bitcast` (::vast::hl::BuiltinBitCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.builtin_bitcast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.cstyle_cast` (::vast::hl::CStyleCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.cstyle_cast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.call` (::vast::hl::CallOp)

VAST call operation


Syntax:

```
operation ::= `hl.call` $callee `(` $operands `)` attr-dict `:` functional-type( $operands, $result )
```

VAST call operation
Interfaces: CallOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.case` (::vast::hl::CaseOp)

VAST case statement


Syntax:

```
operation ::= `hl.case` $lhs $body attr-dict
```

The operation represents a single case of a switch statement.

The generic form of the operation is as follows:

hl.case {
  ... /* lhs/check region */
  hl.value.yield %val : !hl.type
} {
  ... /* body region */
}

It represents a C statement of form `case lhs: body;`.

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.cmp` (::vast::hl::CmpOp)

VAST comparison operation


Syntax:

```
operation ::= `hl.cmp` $predicate type($lhs) $lhs `,` $rhs  attr-dict `->` type($result)
```

VAST comparison operation
Traits: Commutative, SameTypeOperands

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `predicate` | ::vast::hl::PredicateAttr | comparison predicate

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | bool or integer like type

### `hl.cond.yield` (::vast::hl::CondYieldOp)

condition yield operation


Syntax:

```
operation ::= `hl.cond.yield` attr-dict $result `:` type($result)
```

A condition yield operation is used to terminate the region representing
condition expression of control flow operations `IfOp`, `WhileOp`, `ForOp`
and `DoOp`. It yields a boolean value for the conditional branch.

The custom assembly form of the operation is as follows:

hl.cond.yield result : BoolType

Traits: HasParent<IfOp, WhileOp, ForOp, DoOp>, Terminator

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.constant.array` (::vast::hl::ConstantArrayOp)

VAST constant array

VAST constant array
Traits: ConstantLike

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::ArrayAttr | array attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` |

### `hl.constant.float` (::vast::hl::ConstantFloatOp)

VAST floating constant

VAST floating constant
Traits: ConstantLike

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::FloatAttr | arbitrary floating-point attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | float like type

### `hl.constant.string` (::vast::hl::ConstantStringOp)

VAST constant string

VAST constant string
Traits: ConstantLike

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` |

### `hl.continue` (::vast::hl::ContinueOp)

VAST continue statement


Syntax:

```
operation ::= `hl.continue` attr-dict
```

VAST continue statement
Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.ref` (::vast::hl::DeclRefOp)

VAST variable reference declaration


Syntax:

```
operation ::= `hl.ref` $decl attr-dict `:` type($decl)
```

VAST variable reference declaration
Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `decl` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.default` (::vast::hl::DefaultOp)

VAST default statement


Syntax:

```
operation ::= `hl.default` $body attr-dict
```

VAST default statement
Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.deref` (::vast::hl::Deref)

VAST deref operation


Syntax:

```
operation ::= `hl.deref` $addr attr-dict `:` type($addr) `->` type($result)
```

VAST deref operation
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `addr` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to any type

### `hl.assign.fdiv` (::vast::hl::DivFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fdiv` (::vast::hl::DivFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fdiv` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.sdiv` (::vast::hl::DivSAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.sdiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.sdiv` (::vast::hl::DivSOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.sdiv` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.udiv` (::vast::hl::DivUAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.udiv` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.udiv` (::vast::hl::DivUOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.udiv` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.do` (::vast::hl::DoOp)

VAST do-while statement


Syntax:

```
operation ::= `hl.do` $bodyRegion `while` $condRegion attr-dict
```

The operation represents a do-while statement.

The generic form of the operation is as follows:

hl.do {
  ... /* body region */
} cond {
  ... /* cond region */
  hl.cond.yield %cond : !hl.bool
}

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.enum.const` (::vast::hl::EnumConstantOp)

VAST enum constant declaration


Syntax:

```
operation ::= `hl.enum.const` $name `=` $value attr-dict (`init` $init^)?
```

Enumeration constant servers to link name to an enum value.
It is required to be scoped in Enum operation. For example:

```
hl.enum.const "F" = #hl.integer<2> : !hl.int
```

A constant can have a constant expression initializer:

```
hl.enum.const "G" = #hl.integer<12> : !hl.int init  {
  %0 = hl.enumref "F" : !hl.int
  %1 = hl.enumref "C" : !hl.int
  %2 = hl.add %0, %1 : !hl.int
  hl.value.yield %2 : !hl.int
}
```

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `value` | ::mlir::IntegerAttr | arbitrary integer attribute

### `hl.enum` (::vast::hl::EnumDeclOp)

VAST enum declaration


Syntax:

```
operation ::= `hl.enum` $name attr-dict `:` $type $constants
```

Enum declaration serves to declare region for enum constant declarations.
It also defines an underlying type.

Traits: NoTerminator

Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute

### `hl.enumref` (::vast::hl::EnumRefOp)

VAST variable reference declaration


Syntax:

```
operation ::= `hl.enumref` $value attr-dict `:` type($result)
```

VAST variable reference declaration
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `value` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.expr` (::vast::hl::ExprOp)

VAST expression


Syntax:

```
operation ::= `hl.expr` attr-dict `:` type($result) $subexpr
```

VAST expression
Traits: RecursiveSideEffects, SingleBlock

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.field` (::vast::hl::FieldDeclOp)

VAST record field declaration


Syntax:

```
operation ::= `hl.field` $name attr-dict (`bw` $bits^)? `:` $type
```

VAST record field declaration
Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute
| `bits` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `hl.for` (::vast::hl::ForOp)

VAST for statement


Syntax:

```
operation ::= `hl.for` $condRegion `incr` $incrRegion attr-dict `do` $bodyRegion
```

Operation represents a for-loop statement.

The generic form of the operation is as follows:

hl.for {
  ... /* cond region */
  hl.cond.yield %cond : !hl.bool
} incr {
  ... /* increment/update region */
} do {
  ... /* body region */
}

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.global.ref` (::vast::hl::GlobalRefOp)

VAST global variable reference declaration


Syntax:

```
operation ::= `hl.global.ref` $global attr-dict `:` type($result)
```

VAST global variable reference declaration
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `global` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.goto` (::vast::hl::GotoStmt)




Syntax:

```
operation ::= `hl.goto` $label attr-dict
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` |

### `hl.if` (::vast::hl::IfOp)

VAST if statement


Syntax:

```
operation ::= `hl.if` $condRegion `then` $thenRegion (`else` $elseRegion^)? attr-dict
```

The operation takes builders of two mandatory regions -- condition and then
region -- and one builder optional region representing else block of C if statement.
Builders, given the location, build a particular region.

The generic form of the operation is as follows:

hl.if {
  ... /* condition region */
  hl.cond.yield %cond : !hl.bool
} then {
  ... /* then region */
} else {
  ... /* else region */
}

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.implicit_cast` (::vast::hl::ImplicitCastOp)

VAST cast operation


Syntax:

```
operation ::= `hl.implicit_cast` $value $kind attr-dict `:` type($value) `->` type($result)
```

VAST cast operation
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `kind` | ::vast::hl::CastKindAttr | cast kind

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `value` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.indirect_call` (::vast::hl::IndirectCallOp)

VAST call operation


Syntax:

```
operation ::= `hl.indirect_call` $callee `(` $operands `)` attr-dict `:` type( $callee )
```

VAST call operation
Interfaces: CallOpInterface

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `callee` | pointer like type
| `operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.initlist` (::vast::hl::InitListExpr)

VAST initializer list expression


Syntax:

```
operation ::= `hl.initlist` $elements attr-dict `:` functional-type($elements, results)
```

VAST initializer list expression
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `elements` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | any type

### `hl.lnot` (::vast::hl::LNotOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.lnot` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.label.decl` (::vast::hl::LabelDeclOp)




Syntax:

```
operation ::= `hl.label.decl` $name attr-dict `:` type($result)
```


Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` |

### `hl.label` (::vast::hl::LabelStmt)

VAST control flow operation


Syntax:

```
operation ::= `hl.label` $label $substmt attr-dict
```

VAST control flow operation
Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `label` |

### `hl.minus` (::vast::hl::MinusOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.minus` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.fmul` (::vast::hl::MulFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fmul` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fmul` (::vast::hl::MulFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fmul` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.mul` (::vast::hl::MulIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.mul` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.mul` (::vast::hl::MulIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.mul` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: Commutative, SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.not` (::vast::hl::NotOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.not` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.plus` (::vast::hl::PlusOp)

VAST unary type preserving operation


Syntax:

```
operation ::= `hl.plus` $arg attr-dict `:` type($result)
```

Type preserving high-level unary operation assures that argument and
result has the same type.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.post.dec` (::vast::hl::PostDecOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.post.dec` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.post.inc` (::vast::hl::PostIncOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.post.inc` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.pre.dec` (::vast::hl::PreDecOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.pre.dec` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.pre.inc` (::vast::hl::PreIncOp)

VAST unary inplace operation


Syntax:

```
operation ::= `hl.pre.inc` $arg attr-dict `:` type($arg) `->` type($result)
```

Inplace high-level unary operation changes its single argument in place.
It does not produce a new value.

The custom assembly form of the operation is as follows:

%result = <op> %arg : type

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `arg` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.member` (::vast::hl::RecordMemberOp)

VAST record element access operation


Syntax:

```
operation ::= `hl.member` $record `at` $name attr-dict `:` type($record) `->` type($element)
```

VAST record element access operation
#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `record` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `element` | lvalue to any type

### `hl.assign.frem` (::vast::hl::RemFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.frem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.frem` (::vast::hl::RemFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.frem` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.srem` (::vast::hl::RemSAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.srem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.srem` (::vast::hl::RemSOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.srem` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.urem` (::vast::hl::RemUAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.urem` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.urem` (::vast::hl::RemUOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.urem` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.return` (::vast::hl::ReturnOp)




Syntax:

```
operation ::= `hl.return` ($result^ `:` type($result))? attr-dict
```


Traits: Terminator

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.scope` (::vast::hl::ScopeOp)

VAST scope declaration


Syntax:

```
operation ::= `hl.scope` $body attr-dict
```

Scope operation servers to represent explicitly high-level code scope.
Other control flow operations represent scopes implicitly.  It is a
single-region operation.

Traits: NoTerminator

### `hl.sizeof.expr` (::vast::hl::SizeOfExprOp)

VAST expr sizeof operator


Syntax:

```
operation ::= `hl.sizeof.expr` attr-dict `->` type($result) $expr
```

VAST expr sizeof operator
Traits: RecursiveSideEffects

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.sizeof.type` (::vast::hl::SizeOfTypeOp)

VAST type sizeof operator


Syntax:

```
operation ::= `hl.sizeof.type` $type attr-dict `->` type($result)
```

VAST type sizeof operator
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `type` | ::mlir::TypeAttr | any type attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | integer like type

### `hl.skip` (::vast::hl::SkipStmt)

VAST skip statement


Syntax:

```
operation ::= `hl.skip` attr-dict
```

VAST skip statement
Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

### `hl.struct` (::vast::hl::StructDeclOp)

VAST struct declaration


Syntax:

```
operation ::= `hl.struct` $name attr-dict `:` $fields
```

VAST struct declaration
Traits: NoTerminator

Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.assign.fsub` (::vast::hl::SubFAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.fsub` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.fsub` (::vast::hl::SubFOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.fsub` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.assign.sub` (::vast::hl::SubIAssignOp)

VAST compound assign operation


Syntax:

```
operation ::= `hl.assign.sub` $src `to` $dst attr-dict `:` type(operands) `->` type(results)
```

A compound assign operation represents an assignment operation joined
with an arithmetic operation. It requires the same types for both source
and destination arguments.

The custom assembly form of the operation is as follows:

%result = <assign.op> src to dst : type(src)

It represents C compound assignment statement:

dst =<op> src;

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | lvalue to any type
| `dst` | lvalue to any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.sub` (::vast::hl::SubIOp)

VAST arithmetic binary operation


Syntax:

```
operation ::= `hl.sub` $lhs `,` $rhs attr-dict `:` type($result)
```

High-level arithmetic binary operation. This operation takes two operands
and returns one result, each of these is required to be of the same
type.

The custom assembly form of the operation is as follows:

%result = <op> %lhs, %rhs  : type

Traits: SameOperandsAndResultType

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | any type
| `rhs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.subscript` (::vast::hl::SubscriptOp)

VAST array subscript operator


Syntax:

```
operation ::= `hl.subscript` $array `at` ` ` `[` $index `:` type($index) `]` attr-dict
              `:` type($array) `->` type($result)
```

VAST array subscript operator
#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `array` | lvalue to array like type
| `index` | integer like type

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | lvalue to any type

### `hl.switch` (::vast::hl::SwitchOp)

VAST switch statement


Syntax:

```
operation ::= `hl.switch` $condRegion `cases` $cases attr-dict
```

The operation represents a switch statement.

The generic form of the operation is as follows:

hl.switch {
  ... /* cond region */
  hl.value.yield %val : !hl.type
} cases {
  ... /* casesregion */
}

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

### `hl.translation.unit` (::vast::hl::TranslationUnitOp)

VAST translation unit


Syntax:

```
operation ::= `hl.translation.unit` $body attr-dict
```

VAST tranaslation unit
Traits: IsolatedFromAbove, NoTerminator, SymbolTable

### `hl.type.decl` (::vast::hl::TypeDeclOp)

VAST type declaration


Syntax:

```
operation ::= `hl.type.decl` $name attr-dict
```

VAST type declaration
Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.typedef` (::vast::hl::TypeDefOp)

VAST typedef operation


Syntax:

```
operation ::= `hl.typedef` $name attr-dict `:` $type
```

Typedef operation servers to declare named types.
It creates a new type symbol in the current scope to
be referenced as NamedType later.

Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `type` | ::mlir::TypeAttr | any type attribute

### `hl.union` (::vast::hl::UnionDeclOp)

VAST record declaration


Syntax:

```
operation ::= `hl.union` $name attr-dict `:` $fields
```

VAST record declaration
Traits: NoTerminator

Interfaces: NoSideEffect (MemoryEffectOpInterface), VastSymbol

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute

### `hl.unreachable` (::vast::hl::UnreachableOp)

VAST unreachable operation


Syntax:

```
operation ::= `hl.unreachable` attr-dict
```

VAST unreachable operation
Traits: Terminator

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

### `hl.value.yield` (::vast::hl::ValueYieldOp)

value yield operation


Syntax:

```
operation ::= `hl.value.yield` attr-dict $result `:` type($result)
```

A value yield operation is used to terminate the case region of a switch
statement. The yielded value triggers the parent case statement region.

The custom assembly form of the operation is as follows:

hl.value.yield result : type

Traits: Terminator

Interfaces: NoSideEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `hl.var` (::vast::hl::VarDeclOp)

VAST variable declaration


Syntax:

```
operation ::= `hl.var` $name attr-dict ($storageClass^)? ($threadStorageClass^)? `:` type($result)
              (`=` $initializer^)?
              (`allocation_size` $allocation_size^)?
```

VAST variable declaration
Interfaces: VastSymbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `name` | ::mlir::StringAttr | string attribute
| `storageClass` | ::vast::hl::StorageClassAttr | storage class
| `threadStorageClass` | ::vast::hl::TSClassAttr | thread storage class

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | any type

### `hl.while` (::vast::hl::WhileOp)

VAST while statement


Syntax:

```
operation ::= `hl.while` $condRegion `do` $bodyRegion attr-dict
```

The operation takes builders of two mandatory regions -- condition and body
region. Builders, given the location, build a particular region.

The generic form of the operation is as follows:

hl.while {
  ... /* condition region */
  hl.cond.yield %cond : !hl.bool
} do {
  ... /* body region */
}

Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock

## Type definition

### ArrayType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| size | `SizeParam` | size parameter for arrays |
| elementType | `Type` |  |

### BFloat16Type




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### BoolType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### CharType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### DoubleType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### Float128Type




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### FloatType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### HalfType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### Int128Type




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### IntType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### LValueType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |

### LabelType




### LongDoubleType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### LongLongType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### LongType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### NamedType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `::vast::hl::TypeNameAttr` |  |

### PointerType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `Type` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### ShortType




#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| isUnsigned | `bool` |  |
| isConst | `bool` |  |
| isVolatile | `bool` |  |

### VoidType




